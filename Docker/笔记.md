# Docker

## 拉取镜像

``` cmd
docker pull [OPTIONS] <仓库名>:<标签>
```

* `docker pull` ：`Docker` 拉取镜像的命令关键词
* `[OPTIONS]` ：命令选项
* `仓库名` ：仓库名的格式一般为 `<用户名>/<软件名>`。对于 `Docker Hub` ，如果不指定用户名，则默认为 `library` 即官方镜像
* `标签` ：标签是区分镜像不同版本的一个重要参数，`<仓库名>:<标签>`会唯一确定一个镜像。默认为`latest`。

<font color=Blue>例如，我们要从`Docker Hub`官方仓库拉取一个`Ubuntu 14.04`的官方镜像，其语句如下：</font>

``` cmd
docker pull ubuntu:14.04
```

> 由于“伟大的墙”的原因，在国内从`Docker Hub`中拉取镜像的速度可能会比较慢，国内很多云服务商都提供了镜像加速器服务，例如阿里、网易等等。
>
> 以`Linux`系统配置阿里云加速器为例，只需要将下面的命令复制到`Linux`的终端，以`root`用户的身份执行之后，就成功的配置了阿里云加速器了！
>
> ``` cmd
> #以root用户执行以下操作
> mkdir -p /etc/docker
> tee /etc/docker/daemon.json <<-'EOF'
> {#下面的URL可以替换为你自己的阿里云加速地址
> "registry-mirrors": ["https://jxus37ad.mirror.aliyuncs.com "]
> }
> EOF
> systemctl daemon-reload
> systemctl restart docker
> ```

## 启动容器

启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（`stopped`）的容器重新启动。

### 第一种方式：新建并启动

`docker run`命令会基于指定的镜像创建一个容器并且启动它。`docker run`的基本语法如下：

``` cmd
docker run [OPTIONS] 镜像名 [COMMAND] [ARG]
```

- `docker run` :  `Docker`创建并启动容器的命令关键词；
- `OPTIIONS` :  命令选项，最常用的包括`-d`后台运行容器并返回容器`ID`，`-i`以交互模式运行容器，`-t`为容器分配一个伪输入终端，`--name `指定启动容器的名称。更多选项请参考`Docker`帮助文档；
- `镜像名` ：以`<仓库名>：<标签>`的方式来指定；
- `COMMAND` : 设置启动命令，该命令在容器启动后执行；
- `ARG` : 其他一些参数。

> ##### docker run背后的工作
>
> `Docker`在后台运行的标准操作包括：
>
> 1. 检查本地是否存在指定的镜像，不存在就从公有仓库下载启动；
> 2. 利用镜像创建并启动一个容器；
> 3. 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；
> 4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；
> 5. 从地址池配置一个`ip`地址给容器；
> 6. 执行用户指定的启动命令；
> 7. 执行完毕后容器被终止。

<font color=Blue>创建并启动一个容器，容器中具有`ubuntu`的运行环境，输出`hello docker`。</font>

``` cmd
docker run ubuntu:14.04 echo 'hello docker'
```

### 第二种方式：启动一个已经终止的容器

使用容器名或者容器`id`启动一个已经终止的容器。

``` cmd
docker start [OPTIONS] 容器 [容器2...]
```

- `docker start`: `Docker`启动容器的命令关键词；
- `OPTIIONS`: 命令选项；
- `容器`： 需要启动的容器，该容器用“容器`ID`”或“容器名”表示，如果指定了多个容器，那么就将这些容器都启动。

> 但是如果想启动第一个实例创建的容器，既不知道容器的名字（因为我没有指定）而且也不知道它的`id`。该怎么办呢？
>
> **查看容器信息**
>
> `docker ps`
>
> * `docker ps` ：显示所有运行中的容器
> * `docker ps -a` ：可以查看`Docker`环境中所有的容器，包括已经停止的容器

## 停止容器

``` cmd
docker stop [OPTIONS] 容器 [容器2...]
```

- `docker stop`： `Docker`停止容器的命令关键词；
- `OPTIONS`：命令选项，其中`-t`指定等待多少秒后如果容器还没终止，就强行停止，默认等待`10`秒；
- `容器`：需要停止的容器，该容器用“容器`ID`”或“容器名”表示，如果指定了多个容器，那么就将这些容器都停止

> 实际工作中，执行`docker stop`可能并不会立即终止容器，而是需要等待一段时间。前面我们说过，容器实际上是一个进程。而执行`docker stop`之后，首先会向容器的主进程发送一个`SIGTERM`信号，让主进程释放资源保存状态，尝试自己终止。但当等待时间超过了`-t`设置的时间后，会向容器的主进程发送一个`SIGKILL`信号，使容器立即终止。

#### 在什么情况下容器启动后会立即终止？

实际情况中，除了使用`docker stop`命令来强制地终止一个容器以外，当容器的启动命令终结时，容器也自动会终止。

以`docker run --name testcontainer ubuntu echo 'hello docker'`为例，`echo 'hello docker'`就是该容器的启动命令。实际上执行完这条命令后，执行`docker ps -a`，可以发现`testcontainer`容器是处于终止状态的

#### 如何才能使容器启动后不立即终止？

如果容器的`sh`主进程不停止，是不是以为这容器就不会停止？答案是肯定的。因此，如果使启动命令不能执行完毕，或者在执行完启动命令后，容器的`sh`主进程不停止，那么容器在启动后就不会立即终止了！

下面举两个能使容器启动后不立即停止的例子：

##### 将启动命令设置为死循环

``` cmd
docker run ubuntu:14.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

##### 将启动命令设置为“启动一直运行的子进程”

``` cmd
docker run --name first_container -it ubuntu /bin/bash
```

> 执行完这条命令后，创建并启动容器之后，执行`/bin/bash`，会启动一个子进程，此时父进程（也就是容器的主进程`sh`）会进入`sleep`状态，由于`sleep`状态不是终止状态，所以容器会继续运行。

## 进入容器

**进入一个docker容器的几种方法**

1. 使用`ssh`登陆进容器；
2. 使用`nsenter、nsinit`等第三方工具；
3. 使用`docker`本身提供的工具。

这里只介绍使用 `Docker` 本身提供的工具

### docker attach

``` cmd
docker attach 容器
```

（容器 id 可以不用输全，只要能代表容器即可。例如`0539`就是代表容器`ID`以`0539`开头的容器，一般情况下，前`4`位就能唯一标识一个容器了）

### docker exec

``` cmd
docker exec [options] 容器 command [arg]
```

`docker exec` 命令可以在一个运行的容器内部执行一条命令

### attach与exec的主要区别

1. `attach`直接进入容器“启动命令”的终端，不会启动新的进程；
2. `exec`则是在容器中打开新的终端，并且可以启动新的进程；
3. 如果想直接在终端中查看容器“启动命令”的输出，用`attach`；其他情况使用`exec`。

## 删除容器

* `docker rm 容器` ：删除一个处于**终止状态**的容器。
* `docker rm -f 容器` ：强制删除容器
* `docker rm $(docker ps -a -q)` ：删除所有处于终止状态的容器

> 我们知道`docker ps –a`命令可以查看所有容器的信息。而`docker ps –a –q`只查看所有容器的`containerId`。将命令放在`$()`中，会执行命令并返回命令的执行结果。因此`$( docker ps -a -q)`会返回所有容器的`container id`，而`docker rm`只能干掉终止的容器，而如果用`docker rm`删除正在运行的容器时，将不能删除掉。所以可以使用`docker rm $(docker ps -a -q)`来删除所有处于终止状态的容器。

## 删除镜像

如果要删除本地的镜像，可以使用 `docker rmi` （注意`rm`为删除容器，而`rmi`为删除镜像，其中`i`代表`image`）命令，它的具体语法如下：

```
docker rmi [OPTIONS] IMAGE [IMAGE...]
```

其中：

- `docker rmi`：`Docker`删除镜像的命令关键词；
- `OPTIIONS`: 命令选项，`-f`强制删除镜像；
- `IMAGE`：需要删除的镜像。这里的镜像可以用“镜像短`ID`”、“镜像长`ID`”、“镜像名”、“镜像的`digest`”来标识。

**删除`ubuntu:latest`镜像，有以下几种方法：**

1. 镜像短`ID`：`docker rmi 14f6`；（这个代表镜像`id`以`14f6`开头的镜像，一般而言，前四位可以唯一标志，如果不可以，`docker`会提示的）
2. 镜像长`ID`：`docker rmi 14f60031763d`；
3. 镜像名： `docker rmi ubuntu:latest`；
4. 镜像的`digest`：`docker rmi ubuntu@sha256:84c334414e2bfdcae99509a6add166bbb4fa4041dc3fa6af08046a66fed3005f`。

以上的方法都能删除掉`ubuntu:v1`镜像。但日常生活中，我们比较常用的是短`ID`以及镜像名，因为用起来最方便。

### 删除多个镜像

我们可以使用 `docker images -q`来配合使用`docker rmi`，这样可以成批的删除希望删除的镜像。

`docker images -q redis`会输出所有仓库名为`redis`的镜像`id`，所以如果想要删除所有仓库名为`redis`的镜像，可以这么写：

```
docker rmi $(docker images –q redis)
```

如果想要删除所有镜像，可以这么写：

```
docker rmi $(docker images –qa)
```

如果想要使用`docker rmi`删除一个镜像，需要注意需要先将使用该镜像的容器删除掉，否则该镜像不能删除成功。当然也可以使用`docker rmi -f`强制删除该镜像！

## Dockerfile

> 镜像的定制实际上就是定制每一层所添加的配置、文件。那么如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是`Dockerfile`。

* 在`Dockerfile`中，指令不区分大小写，但是为了与参数区分，推荐大写。

* `Docker`会顺序执行`Dockerfile`中的指令，第一条必须是`FROM`指令，它用于指定构建镜像的基础镜像。
* 在`Dockerfile`中，以`#`开头的行是注释。

### FROM 指令和 RUN 指令

``` dockerfile
FROM <image>[:<tag>]
```

`FROM`指令的功能是为后面的指令提供基础镜像，因此一个有效的`Dockerfile`必须以`FROM`指令作为第一条非注解指令。若`FROM`指令中`tag`参数为空，则`tag`默认为`latest`；若参数`image`或`tag`指定镜像不存在，则返回错误。

``` dockerfile
RUN <command> # shell格式
RUN ["executable","param1","param2"] # exec格式，非常推荐
```

`RUN `指令是用来执行命令行命令的。`RUN`指令会在前一条命令创建出的镜像的基础上创建一个容器，并在容器中运行命令。在命令结束运行后提交新容器为新镜像，新镜像被`Dockerfile`的下一条指令使用。

### 构建一个镜像

下面举一个实例，使用`Dockerfile`构建一个名为`testimage`的镜像，该镜像具备`ubuntu:latest`的运行环境，而且在镜像的/目录下创建了一个`dir1`文件夹。

``` cmd
#先创建一个新的空文件夹
mkdir newdir
#进入这个新文件夹中
cd newdir
#创建一个Dockerfile文件
touch Dockerfile
#补全Dockerfile的内容（为了方便展示，这里用的是echo向Dockerfile中输入内容）
echo "FROM ubuntu:latest" > Dockerfile
echo "RUN mkdir /dir1" >> Dockerfile
#使用该Dockerfile构建一个名为testimage的镜像
docker build -t testimage .
```

该`docker build`的命令格式如下：

```cmd
docker build [OPTIONS] 上下文路径|URL
```

其中：

- `docker build`： 用`Dockerfile`构建镜像的命令关键词；
- `[OPTIONS]`: 命令选项，常用的指令包括`-t`指定镜像的名字，`-f`显示指定`Dockerfile`，如果不使用`-f`，则默认将上下文路径下的名为`Dockerfile`的文件认为是构建镜像的“`Dockerfile`”；
- `上下文路径|URL`： 指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件。

### COPY 指令和 ADD 指令

``` dockerfile
COPY <源路径> <目标路径>
```

`COPY` 指令将从构建上下文目录中 <源路径> 的文件或目录复制到新的一层的镜像内的 <目标路径> 位置。<源路径>所指定的源必须在上下文中，即必须是上下文根目录的相对路径！<目标路径> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR`指令来指定，后面介绍）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建目录。

``` dockerfile
ADD <源路径> <目标路径> # 更高级的文件复制
```

`ADD`与`COPY`指令在功能上十分相似，但是在`COPY`的基础上增加了一些功能。比如，源路径可以是一个指向一个网络文件的`URL`，这种情况下，`Docker`引擎会试图下载这个`URL`指向的文件到<目标路径>去。

此外，当<源路径>为一个`tar`压缩文件时，该压缩文件在被复制到容器中时会被解压提取。

### CMD 指令

**CMD 指定默认的容器主进程启动命令**

格式：`CMD <command>`（`shell`格式）或  `CMD [“executable”,”param1”,”param2”]`(`exec`格式，推荐格式)或 `CMD[”param1”,”param2”]`。(为`ENTRYPOINT`指令提供参数)

`CMD`指令提供容器启动时运行的默认命令，例如`ubuntu`镜像默认的`CMD`是`/bin/bash`，因此我们可以直接使用 `docker run -it ubuntu`进入`bash`。