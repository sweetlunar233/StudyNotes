# JavaScript

## JavaScript与HTML

### 使用内置script标签对的方式嵌入JS代码

将 JavaScript 嵌入到 HTML 中有两种方法，对于内容较少的 JavaScript 代码，常采用将 JavaScript 代码直接写在 HTML 中的做法。

在`<script></script>`之间写入 JavaScript 代码，然后将标签连同代码放入到`<head></head>`或者`<body></body>`之间，常见的是放在`<head></head>`之间，因为这样 JavaScript 和 HTML 的主体内容相对分开，便于阅读。如下是一个实例：

``` html
<!DOCTYPE html>
<html>
    <head>
        <script>
        console.log("在HTML中嵌入JavaScript，这里是JS部分");
        </script>
    </head>
    <body>
    <!--这里是HTML的主体部分-->
    </body>
</html>
```

### 引入外置代码源文件的方式在HTML中嵌入JavaScript

对于较长的 JavaScript 源代码，使用内置代码的方式会使得 HTML 代码过长，不符合程序开发模块化的要义。这时可采用引入外部代码文件的方式，即将所有的 JavaScript 代码放在一个扩展名为 `.js` 的文档中，然后将 script 标签的 `src` 属性值设置为待引入的 JavaScript 文件的路径名，再将 `<script></script>` 放在 `<head></head>` 或者 `<body></body>` 之间。如下是一个实例：

我们将 JavaScript 代码放在 `myjs.js` 中，HTML 代码放在 `hello.html` 中，两者在同一个目录下：

``` html
<!DOCTYPE html>
<html>
    <head>
        <script src="myjs.js">
        </script>
    </head>
    <body>
    <!--这里是HTML的主体部分-->
    </body>
</html>
```

## 输出

### 弹出对话框模式

通过 `alert()` 函数弹出对话框，这是最常用的方式。在 `script` 标签下，调用 `window.alert()` 函数，括号内填入输出的内容。

``` html
<!DOCTYPE html>
<html>
    <body>
        <script>
            window.alert("Hello,World!");
        </script>
    </body>
</html>
```

以浏览器方式打开刚刚建立的`HTMl`文件，在浏览器上面可以看到，如图：

![img](https://data.educoder.net/api/attachments/186147)

### 控制台模式

通过`console`输出到控制台，在`script`标签下，调用`console.log()`函数，括号内填入输出的内容，以浏览器打开下面的代码后，按`F12`键即可在浏览器的控制台中实现输出。

```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            console.log("Hello,World!");
        </script>
    </body>
</html>
```

在浏览器的控制台可以看到如下的内容，如图：

![img](https://data.educoder.net/api/attachments/185411)

除此之外，还有`console.error()`，`console.warn()`等方式实现输出，分别表示输出错误，输出警告。

### 页面输出模式

通过`document.write()`实现输出到页面。在`document.write()`函数的括号中填入输出的内容即可。例子如下：

```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            document.write("Hello,World!");
        </script>
    </body>
</html>
```

浏览器的页面输出如图3：

![img](https://data.educoder.net/api/attachments/185417)

## 变量

不同于 C 或 Java，JavaScript 是一种动态类型的语言，即申明的时候不指定变量的数据类型，而在运行的时候根据变量的具体值动态的判断变量的数据类型。

* 变量名以字母或者 `$` 或者 `_` 开头；
* 变量名只能含有字母、数字、下划线和美元符号；
* 大小写敏感；
* 不能使用保留的关键字，如 html 、 var、function 等，这一条一定要记住，使用关键字造成的错误往往很难排除。

### 申明、初始化和赋值

- 变量的申明 在 JavaScript 中，申明变量以关键字 var 开头，空一格后再接变量的名字；当然，可以一次申明多个变量，这时 var 只需要出现一次，多个变量名之间用英文的逗号隔开即可。如：

```javascript
var myvar1;    // 申明变量
"myvar1"var myvar2,myvar3,myvar4;    // 一次申明三个变量
```

- 变量的初始化和赋值 用一个等号连接变量名和变量的值即可，对于数字的赋值，直接用等号连接数字和变量，对于字符串的赋值，需要将字符串包含在英文双引号之中。

``` javascript
var numberVar; //申明
numberVar = 1; //赋值
var stringVar = "I am a string"; //申明 + 初始化
```

### 变量的作用域

JavaScript 的变量也分为全局变量和局部变量。与 java 差不多。

> 如果局部变量和全局变量的名字相同，那么在函数内部全局变量会被局部变量覆盖。

```javascript
var myVar = 1;    // 全局变量
function scope() {
  var myVar = 2;    // 局部变量，覆盖了上面的值
  console.log(myVar);    // 输出2
}
```

### 申明提前

JavaScript 局部变量有一个很重要的概念，叫申明提前，我们先来看一个例子。

``` javascript
var wholeVar = 1;    // 全局变量
function myTest() {
  	console.log(wholeVar);
 	var wholeVar = 2;
  	console.log(wholeVar);
}
```

关于第三行的输出，你的第一反应一定是`1`吧，正确答案是`undefined`。这是因为**在函数内部，变量不论在何处申明，都应该看成是在最开始申明**（赋值不会看成是在最开始赋值，这就是不输出`2`的原因），这就是“申明提前”，所以，以上代码等价于：

```javascript
var wholeVar = 1;
function myTest() {    
    var wholeVar;    // 申明提前了，覆盖了全局变量
    console.log(wholeVar);    // 上面只申明，没赋值
    wholeVar = 2;
    console.log(wholeVar);
}
```

## 数据类型

### 数字类型

JavaScript 中的数字类型指整数和浮点数。

* 支持16进制的整数，在所要表示的16进制数前面加上`0x`或者`0X`即可，如`0x1f`表示整数31。
* 支持科学记数法，如`2e3`表示2000

* 对于一般的数学运算，如加减乘除，和数学上的表达方式相同。对于稍微复杂的运算，需要通过 `Math` 对象定义的函数来实现，下面是一些例子：

```javascript
var number1 = 0X11;    // 17
var number2 = 2.01e-2;    // 2.01*0.01
var number3 = Math.sqrt(9);    // 计算9的平方根
```

### 字符串

* 在 JavaScript 中，没有字符的说法，字符看成长度为1的字符串，字符串指包含在单引号或者双引号中的文本。
* 需要用转义字符将引号变为普通字符。

### 布尔型

布尔型：有两种逻辑状态的类型，它的值只有 true 和 false 两个，分别表示正确、错误。

```javascript
var boolType1 = true;
var boolType2 = false;
```

### 数组

 JavaScript 数组中的元素可以是不同的数据类型。

``` javascript
var myArray = [1,2,true,"string",3.2];
```

> 数组的常用方法在后面介绍

### null 和 undefined

undefined 表示某个变量没有被赋值，比如，变量在申明的时候没有赋值，那么它的值就是 undefined 。null 是对象，是一个空的对象引用。

``` javascript
var myVar;
console.log(myVar);
console.log(a);
```

如上面所示，尝试输出变量 myVar ，结果会输出 undefined ，因为这个变量只申明，没有赋值。而尝试输出变量 a 会产生错误，因为这个变量没有定义，是一个空的对象引用。

### 对象类型

JavaScript 是面向对象的语言，严格的来说，在 JavaScript 中，一切都可称为对象。但是我们这里介绍的对象仅指键值对的集合，可以类比于 C 中的结构体或者 Java 中的对象。

对象的创建：

``` javascript
var student = {
    name:"Peter",
    age:23,
    gender:male
};    // 申明并初始化对象
```

对象的使用，比如获取对象里的某个属性的值：

``` javascript
console.log(student.name);    // 输出"Peter"
```

还可以更改这个属性的值：

``` javascript
student.name = "Bob";
console.log(student.name);    // 输出"Bob"
```

## 比较和逻辑运算符

### 比较运算符

JavaScript 中的比较运算符有`==`,`===`,`>`,`<`,`!=`,`>=`等。

* `==`叫做相等，`===`叫做严格相等。双等号和三等号的区别是：三等号要求数据类型和值都相等，双等号只需要值相等即可，相等包含严格相等。
  * 从比较过程来看，严格相等先比较两个对象的数据类型是否相等，不相等则结束比较，返回 false ，相等在数据类型不同时，尝试进行数据类型转换，例如，在字符串和数字的比较中，字符串会被转为数字再比较；布尔值 true 转为数字1，布尔值 false 转为数字 0。
  * 需要特别注意的是，以上仅仅适用于非对象类型。对于对象类型，相等或者严格相等比较的都是对象的引用，而不是具体的值，就是说，一个对象和其他任何对象都是不相等的，即使两者属性、值都相等。
* 不等 对应于上面的等号，不等号也有两种：`!=`和`!==`。 `!=`和`==`互为相反，`==`成立，`!=`一定不成立。 `!==`和`===`互为相反，严格相等成立，则严格不相等不成立。
* 其它 大于，小于，大于等于，小于等于的比较规则如下：
  * 比较的两个对象都是数字，按照数学中数字的比较方法。 
  * 数字和字符串比较，字符串转为数字后再比较。 
  * 字符串和字符串比较，从第一个字符开始，逐个比较，发现不相等立即返回。字符按照`ASCII`编码值的大小比较。当一个字符串结束另外一个字符串还有，还没有比较出大小，则长的字符串较大。

### 逻辑运算符

- 逻辑与 逻辑与有两个操作数，中间用`&&`连接，只有两个操作数都是 true 结果才是 true； 其中一个操作数不是布尔型，当左操作数为真值时，返回右操作数。当左操作数为假值时，返回左操作数。
- 逻辑或 逻辑或同样有两个操作数，用`||`连接，至少有一个操作数为 true 时结果为 true； 其中一个操作数不是布尔型，当左操作数为真值时，返回左操作数。当左操作数为假值时，返回右操作数。
- 逻辑非 逻辑非只有一个操作数，`!`后连接操作数或表达式，意思是将操作数取反； 如果操作数不是布尔型，编译器首先将其他类型转换为布尔型，然后返回 true 或者 false 。

## 创建对象

### 对象字面量

这是最常用的创建对象的方法，通过新建一个键值对的集合（对象字面量）创建对象，如下：

```javascript
var song = {
    name:"Liekkas",
    time:180,
    "song language":English,
    singer: {
        singerName:"Sofia Jannok",
        singerAge:30
    }
};
```

键值对中的键指的是属性的名字，若其中含有空格，名字需要用双引号包含在内。值指的是属性的值，可以是基本类型：如字符串，数字，布尔型，也可以是一个对象。键值对之间用逗号隔开，最后一个键值对后面没有逗号，所有的键值对在一个大括号中。

### 通过关键字new创建对象

通过`new`关键字创建对象也是一个常用的方法。如下：

```javascript
var Store = new Object();    // 创建对象的一个实例
Store.name = "lofo Market";
Store.location = "NO.13 Five Avenue";
Store.salesVolume = 1000000;
```

通过上面的代码，我们就能创建一个名为`Store`的对象。

### 通过工厂方法创建对象

工厂方法就是通过函数创建对象，函数封装了创建对象的过程。

这是一种通过函数创建对象的方法，函数封装了对象的创建过程，创建新对象时只需要调用该函数即可。这种方法适合于一次创建多个对象。

```javascript
// 对象的创建函数
function createStoreObject(name,location,salesVolume) {
    var store = new Object();
    store.name = name;
    store.locaion = location;
    store.salesVolume = salesVolume;
    store.display = function() {
        console.log(this.name);
    };
    return store;
}// 利用该函数创建一个对象
var store1 = createStoreObject("panda express","No.1,People Street",200000);
```

这样就创建了一个名为`store1`的对象，注意这个对象除了属性之外还有一个方法`display`。要创建更多的类似`store1`的对象，直接调用该函数即可。

### 使用构造函数创建对象

上面虽然也是通过函数创建对象，但不是构造函数，只是普通函数。构造函数名必须以大写字母开头，函数体内没有返回语句。

```javascript
// 构造函数
function Store(name,location,salesVolume) {
    this.name = name;
    this.locaion = location;
    this.salesVolume = salesVolume;}
// 创建对象的实例
var myStore = new Store("KeyExp","No.1,L.Street",540000);
```

上面的代码首先是`Store`对象的构造函数，然后用该构造函数创建了`Store`对象的一个实例`myStore`。

### 使用原型(prototype)创建对象

当我们创建一个函数时，函数就会自动拥有一个`prototype`属性，这个属性的值是一个对象，这个对象被称为该函数的原型对象。也可以叫做原型。

当用`new`关键字加函数的模式创建一个对象时，这个对象就会有一个默认的不可见的属性`[[Prototype]]`，该属性的值就是上面提到的原型对象。如图所示：

![img](https://data.educoder.net/api/attachments/187046)

JavaScript 中每个对象都有一个属性`[[Prototype]]`，指向它的原型对象，该原型对象又具有一个自己的`[[Prototype]]`，层层向上直到一个对象的原型为`null`。根据定义，`null` 没有原型，并作为这个原型链中的最后一个环节。如图所示：

![img](https://data.educoder.net/api/attachments/187047)

这种方法是对使用构造函数创建对象的改进，使用构造函数创建一个对象时，会把构造函数中的方法（上面的构造函数只有属性的键值对，没有方法）都创建一遍，浪费内存，使用原型不存在这个问题。

```javascript
function Store() {};
Store.prototype.name = "SF Express";
Store.prototype.locaion = "Hong Kong";
Store.prototype.salesVolume = 1200000000;
// 创建对象
var myStore = new Store();// 创建一个新的对象
var hisStore = new Store();
hisStore.name = "STO Express";    // 覆盖了原来的name属性
```

这种方法的好处是，创建一个新的对象时，可以更改部分属性的值。

## 属性

### 属性的获取

#### 方式一

属性的获取有两种方式，一种是使用`.`符号，符号左侧是对象的名字，符号右侧是属性的名字，如下：

```javascript
var student = {name:"Alice",gender:"girl"};
console.log(student.name);    // 输出Alice
```

这种情况下属性名必须是静态的字符串，即不能是通过计算或者字符串的拼接形成的字符串。

#### 方式二

另外一种是使用`[""]`符号，符号的左边是对象的名字，双引号中间是属性的名字，这种情况下属性名可以是一个表达式，只要表达式的值是一个字符串即可。如下：

```javascript
var student = {name:"Alice",gender:"girl"};
console.log(student["name"]);    //输出Alice
```

有两种情况必须使用第二种方式：

- 属性名含有空格字符，如`student["first name"]`，这时不能用`student.first name`代替，编译器无法解释后者；
- 属性名动态生成，比如用`for`循环获取前端连续 id 的值，这种 id 名之间一般有特定关系。如下面的例子：

```javascript
for(int i = 0;i < 5;i ++) {
    console.log(student["id"+i]);
}
```

### 属性的修改与新增

属性的修改指修改已有属性的值，这个直接用赋值符号即可。

属性的新增与修改在形式上完全相同，区别仅在于编译器会根据属性的名字判断是否有该属性，有则修改，没有则新增。

```javascript
var student = {
    name:"Kim",
    age:21
};
student.age = 20;//修改属性，覆盖了原来的值21
student.gender = "female";//新增属性gender
```

### 删除属性

JavaScript 中的属性还可以删除，删除通过`delete`运算符实现。删除成功返回布尔型`true`，删除失败也是返回`true`，所以在删除之前需要判断一个属性是否存在。

``` javascript
var Store = new Object();
Store.name = "lofo Market";
Store.location = "NO.13 Five Avenue";
console.log(delete Store.name);    // 删除成功，输出true
console.log(Store.name);    // 已删除，返回undefined
delete Store.prototype;    // 删除失败，非自有属性
```

### 属性的检测

属性的检测指检查对象是否有某个属性或者方法，需要使用运算符`in`，`in`的左侧是属性或者方法名，右侧是检查对象，对象有该属性或者方法则返回`true`，否则返回`false`，如下：

``` javascript
var school = {
    name:"SJTU",
    location:"ShangHai",
    studentNum:40000,
    display:function() {
          console.log(this.name);
    }
};
// 检测属性
console.log("name" in school);    // 输出true
console.log("sales" in school);    // 输出false
// 检测方法
console.log("display" in school);    // 输出true
console.log("print" in school);    // 输出false
```

还可以用`hasOwnProperty()`检测对象是否具有某个自有属性或方法。括号内的参数是属性或者方法的名字。

所谓自有属性或者方法，是指对象自己定义的属性或者方法，而不是从原型链上继承来的。关于原型链，请参考本实训第一关。

``` javascript
var school = {
    name:"SJTU",
    location:"ShangHai",
    studentNum:40000,
    display:function() {
          console.log(this.name);
    }
};
console.log(school.hasOwnProperty("studentNum"));    // true
console.log(school.hasOwnProperty("hasOwnProperty"));    // false
```

### 属性的枚举

定义：属性的枚举指按顺序逐个的列出属性的名字。

> 首先要知道一个概念：可枚举性（`enumerable`），这是对象的属性的一个性质，用户自己定义的属性默认为可枚举，系统内置的对象的属性默认为不可枚举。

枚举属性有三种方法：

- `for...in...`循环；

可以枚举所有可枚举的属性，包括继承的属性。如下：

``` javascript
// 首先定义一个school对象，它从原型链上继承的属性都是不可枚举的，而下面自定义的四个属性或者方法都是可枚举的
var school = {
    name:"SJTU",
    location:"ShangHai",
    studentNum:40000,
    display:function() {
          console.log(this.name);
    }
};
// 枚举school的属性
// 下面的圆括号中的att表示对象的属性，school表示对象
for(var att in school) {
    // 依次输出name,location,studentNum,display
    console.log(att);
}
```

圆括号里面的表达式中，`att`表示对象的属性，`school`表示该对象，这个循环将依次遍历对象的所有可枚举属性，每次输出一个属性的值。

- `Object.getOwnPropertyNames()`；

括号中有一个参数，是要枚举的对象。该表达式将返回对象的所有自有属性的名字，不区分是否可枚举，结果以字符串数组的形式呈现，如下：

``` javascript
// 定义一个school对象
var school = {
    name:"SJTU",
    location:"ShangHai",
    studentNum:40000,
    display:function() {
          console.log(this.name);
    }
};
// 为school对象增加一个不可枚举的属性range
Object.defineProperty(school, "range", {
    value: 4,    // 设置range属性的值
    enumerable: false    // 设置range属性为不可枚举
});
// 输出["name","location","studentNum","display","range"]
console.log(Object.getOwnPropertyNames(school));
```

* `Object.keys()`；  括号中有一个参数，是要枚举的对象。该表达式返回可枚举的自有属性，以字符串数组的形式。所以这里对属性的要求更加严格，既要求是自有属性，又要求可枚举。  

![image-20240418230429732](C:\Users\dcx13\AppData\Roaming\Typora\typora-user-images\image-20240418230429732.png)

## 数组的常用方法

### 查找元素的位置

根据值查找元素的位置，有两个方法：`indexOf()`和`lastIndexOf()`，前者从索引小处往大搜索，后者相反。都返回第一次遇到该元素时的索引。

两者都有两个参数，第一个参数为要查找的元素，第二个参数可选，为搜索的起点索引。第二个参数可以是负数，`-1`表示倒数第一个元素，`-2`表示倒数第二个元素，依次类推。

返回值：

* 大于等于 0：查找成功
* -1：没有找到

### 数组的合并

`concat()`实现数组合并，其形式是`数组a.concat(数组b)`或者 `a.concat(值)`，合并之后返回新数组，新数组为数组`a`后面连接数组`b`，但是数组`a`和`b`不变。

### 数组倒置

`reverse()`实现数组倒置，无参数，返回倒置后的数组，同时调用该方法的数组也会被倒置。称为就地逆置。

### 元素合并

`join()`将数组的所有元素连接起来组成字符串，参数为元素之间的分隔符，默认逗号。

``` javascript
ar sArray = ["June","July","August"];
console.log(sArray.join());//输出June,July,August
console.log(sArray.join("+"));//输出June+July+August
```

### 元素排序

`sort()`实现数据元素排序，不带参数表示元素按照`ASCII`表从小到大排序

``` javascript
var stringArray = ["a","ab","b","aa"];
stringArray.sort();
console.log(stringArray);//输出["a","aa","ab","b"]
```

带参数的格式如下：

```javascript
arr.sort(function(a,b){
    return a-b;  //升序排列
})
```

或者：

```javascript
arr.sort(function(a,b){
    return b-a;  //降序排列
})
```

### 提取子数组

`slice()`返回切割出的子数组，不修改原来的数组。

它有两个整数参数`a`和`b`，`a`表示切割的起点，该点属于子数组；`b`可选，表示切割的终点，该点不属于子数组。（左闭右开区间）

`a`和`b`都可以为负数，如`-1`表示倒数第一个位置，依次类推。

### 追加元素

`push()` 方法可以将一个或多个元素添加到数组的末尾，并返回新数组的长度

``` javascript
var arr = [1, 2, 3, 4, 5];
arr.push(6);
console.log(arr); // [1, 2, 3, 4, 5, 6];
```

## JSON 对象

> 定义一个`JavaScript`对象： 
>
> ```javascript
> var myObject = {
>     id:1,
>     name:"Peter Bruce",
>     "first name":"Bruce",
>     display:function() {
>         console.log(this.name);
>     }
> }
> ```
>
> 定义一个`JSON`对象： 
>
> ```javascript
> {"id":1,"name":"Peter Bruce","first name":"Bruce"}
> ```
>
> 三点区别：
>
> - `JSON`对象的属性名（`key`）必须被包含在双引号之中，而`JavaScript`对象除了有空格的属性名、中间有连字符`-`的属性名必须在双引号之中外，其它随意；
> - 不能在`JSON`对象中定义方法，而在`JavaScript`对象中可以；
> - `JSON`对象可以被很多语言操作，而`JavaScript`对象只有`JS`自己可以识别。

**定义JSON对象**的方法如下：用一个`{}`包含在内，内部是若干个属性名和属性值构成的键值对，键值对之间用`,`隔开，属性名和属性值之间用`:`隔开，属性值可以是以下任意一种数据类型的数据：数字、字符串、`JSON`数组、`JSON`对象、`null`。

属性值是`JSON`数组或者`JSON`对象的情况稍复杂，后面将介绍。

##### 在JavaScript中使用JSON对象

支持`JSON`的语言都能够使用`JSON`对象，这里仅介绍在`JavaScript`中如何使用`JSON`对象。 

- 在`JavaScript`中定义一个`JSON`对象：

```javascript
var jsonObject = {"name":"js","number":2};
```

- 操作属性，使用`.`或者`[]`： 
- 删除属性，使用`delete`： 
- 遍历属性，使用`for-in`循环： 
